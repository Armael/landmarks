{
  "name": "Landmarks",
  "tagline": "A Simple Profiling Library for OCaml",
  "body": "Landmarks: A Simple Profiling Library\r\n=====================================\r\n\r\n*Landmarks* is a simple profiling library for OCaml. It provides primitives to\r\ndelimit portions of code and measure the performance of instrumented code at\r\nruntime. The available measures are obtained by aggregating CPU cycles (using\r\nthe cpu's time stamp counter), applicative time (using `Sys.time`) and\r\nallocated bytes (with `Gc.allocated_bytes`). The instrumentation of the code\r\nmay either done by hand, automatically or semi-automatically using a PPX\r\nextension.\r\n\r\nDuring the execution of your program, the traversal of instrumented code by\r\nthe control flow is recorded as a \"callgraph\" that carries the collected\r\nmeasures. The results may be browsed either directly on the console, or\r\nby exporting results to a simple web-application (that you can either build\r\nlocally or [access online](http://LexiFi.github.io/landmarks/viewer.html)).\r\n\r\nThis tool is intended to be used as a way to find where the time is spent in\r\nyour programs (and not benchmark independent pieces of code like\r\n[Core_bench](https://github.com/janestreet/core_bench)) while providing results\r\nthat only correspond to the instrumented portion of your OCaml code (contrary to\r\ntools that directly work with the binary executable like\r\n[gprof](https://sourceware.org/binutils/docs/gprof/) or\r\n[perf](https://perf.wiki.kernel.org)).\r\n\r\nFor more information, you may browse the [API](http://LexiFi.github.io/landmarks/api/).\r\n\r\nInstallation\r\n------------\r\n\r\n- Requirements:\r\n   * findlib (aka ocamlfind)\r\n\r\n- Optional requirements (only for building the viewer):\r\n   * gen_js_api\r\n   * js_of_ocaml\r\n\r\n- With opam:\r\n```\r\nopam install landmarks\r\n```\r\n\r\n- With opam (development version):\r\n```\r\nopam pin add landmarks https://github.com/LexiFi/landmarks.git\r\n```\r\n\r\n- Manually:\r\n```\r\ngit clone https://github.com/LexiFi/landmarks.git\r\ncd landmarks\r\nmake\r\nmake install\r\n```\r\nand `make uninstall` to remove installed files.\r\n\r\nUsage\r\n-----\r\n\r\n* Compiling and linking:\r\n```\r\n  ocamlfind ocamlopt -c -package landmarks prog.ml\r\n  ocamlfind ocamlopt -o prog -package landmarks -linkpkg prog.cmx\r\n```\r\nYou can replace \"ocamlopt\" by \"ocamlc\" to compile the program in\r\nbytecode.\r\n\r\n* With the PPX extension:\r\n```\r\n  ocamlfind ocamlopt -c -package landmarks.ppx prog.ml\r\n  ocamlfind ocamlopt -o prog -package landmarks -linkpkg prog.cmx\r\n```\r\n\r\n* Launching the viewer (when available):\r\n```\r\nx-www-browser $(ocamlfind query landmarks)/landmarks_viewer.html\r\n```\r\nYou may want to replace \"x-www-browser\" with your system's way to\r\ninvoke your favorite web-browser from the command line. It has\r\nto support javascript.\r\n\r\n\r\nBenchmarking manually\r\n---------------------\r\n\r\nThere are three main primitives:\r\n```ocaml\r\n  val register: string -> landmark\r\n  val enter: landmark -> unit\r\n  val exit: landmark -> unit\r\n```\r\n\r\nThe `register` function declares new landmarks and should be used at the\r\ntoplevel. The functions `enter` and `exit` are used to delimit the portion\r\nof code attached to a landmark. At the end of the profiling, we retrieve for\r\neach landmark the aggregated time information spent executing the corresponding\r\npiece of code. During the execution, a trace of each visited landmark is also\r\nrecorded in order to build a \"callgraph\".\r\n\r\nFor example:\r\n```ocaml\r\nopen Landmark\r\n\r\nlet loop = register \"loop\"\r\nlet sleep = register \"sleep\"\r\nlet main = register \"main\"\r\n\r\nlet zzz () =\r\n  enter sleep;\r\n    Unix.sleep 1;\r\n  exit sleep\r\n\r\nlet () =\r\n  begin\r\n    start_profiling ();\r\n    enter main;\r\n      enter loop;\r\n        for _ = 1 to 9 do\r\n          zzz ()\r\n        done;\r\n      exit loop;\r\n      zzz ();\r\n    exit main;\r\n  end\r\n```\r\n(This file can be compiled with\r\n  `ocamlfind ocamlc -o prog -package landmarks -package unix -linkpkg prog.ml`)\r\n\r\nThe induced callgraph is:\r\n```\r\n- 100.00% : main\r\n|   - 90.00% : loop\r\n|   |   - 100.00% : sleep\r\n|   - 10.00% : sleep\r\n\r\n```\r\nwhich can be paraphrased as:\r\n- 100% of time is spent inside the main landmark,\r\n- 90% of time spent inside the main landmark is spent in the loop landmark,\r\n- 10% of time spent inside the main landmark is spent in the sleep landmark,\r\n- 100% of the time spent in loop is spent in the sleep landmark.\r\n\r\n\r\nThe `clock()` function\r\n----------------------\r\n\r\nThe library provides a binding to the [high-performance cycles\r\ncounter](https://en.wikipedia.org/wiki/Time_Stamp_Counter) for x86 32 and 64\r\nbits architectures (note that you may use the `landmarks-noc.cm(x)a` archive to\r\nprovide your own implementation). It is used to measure the time spent inside\r\ninstrumented code.\r\n\r\n\r\nThe PPX extension point\r\n-----------------------\r\n\r\nTo avoid writing boilerplate code, you may use the ppx extension distributed\r\nwith this package. It allows the programmer to instrument expressions using\r\nannotation and to automatically instrument top-level functions.\r\n\r\n### Annotations\r\n\r\nThe value `expr [@landmark \"name\"]` is expanded into\r\n```ocaml\r\n  Landmark.enter __generated_landmark_1;\r\n  let r =\r\n    try expr with e -> Landmark.exit __generated_landmark_1; raise e\r\n  in\r\n  Landmark.exit __generated_landmark_1;\r\n  r\r\n```\r\nand the declaration\r\n```ocaml\r\n  let __generated_landmark_1 = Landmark.register \"name\"\r\n```\r\nis appended at the top-level.\r\n\r\nIt should be pointed out that this transformation does not preserve\r\ntail-recursive calls (and also prevents some polymorphism generalization).\r\nTo get around these problems, it is recommended to use the other provided\r\nextension around `let ... in` and `let rec ... in`:\r\n```ocaml\r\nlet[@landmark] f = body\r\n```\r\nwhich is expanded in :\r\n```ocaml\r\nlet __generated_landmark_2 = Landmark.register \"f\"\r\nlet f = body\r\nlet f x1 ... xn =\r\n  Landmark.enter __generated_landmark_2;\r\n  let r =\r\n    try f x1 ... xn with e -> Landmark.exit __generated_landmark_2; raise e\r\n  in\r\n  Landmark.exit __generated_landmark_2;\r\n  r\r\n```\r\nwhen the arity `n` of `f` is obtained by counting the shallow occurrences\r\nof `fun ... ->` and `function ... -> ` in `body`.\r\n\r\n### Automatic instrumentation\r\n\r\nThe structure annotations `[@@@landmark \"auto\"]` and `[@@@landmark \"auto-off\"]`\r\nactivates or deactivates the automatic instrumentation of top-level functions\r\nin a module. In automatic mode, all functions declarations are implicitly\r\nannotated.\r\n\r\nThe OCAML_LANDMARKS environment variable\r\n----------------------------------------\r\n\r\nWhen the landmarks module is loaded by an instrumented program and when the ppx\r\nrewritter is executed, the environment variable `OCAML_LANDMARKS` is read. If\r\nit exists the function `start_profiling` is called by the landmark module.\r\nThis variable is parsed as a comma-separated list of items of the form\r\n`option=argument` or `option` where `option` is:\r\n\r\n * `format` with possible arguments: `textual` (default) or `json`. It controls\r\n    the output format of the profiling which is either a console friendly\r\n    representation or json encoding of the callgraph.\r\n\r\n * `output` with possible argument: `stderr` (default), `stdout`, `temporary`,\r\n   `\"<file>\"` (where `<file>` is the path a file). It tells where to output the\r\n    results of the profiling. With `temporary` it will print it in a temporary\r\n    file (the name of this file will be printed on the console).\r\n\r\n * `auto` with no argument. This option is only read by the ppx extension. It\r\n    turns on the automatic instrumentation by default (behaves as if all modules\r\n    starts with the annotation `[@@@landmark \"auto\"]`).\r\n\r\n * `debug` with no argument. Activates a verbose mode that outputs traces on\r\n   stderr each time the landmarks primitives are called.\r\n\r\n * `time` with no argument. Also collect `Sys.time` timestamps during profiling.\r\n\r\n * `off` with no argument. Disable profiling.\r\n\r\n * `allocation` with no argument. Also collect `Gc.allocated_byte` data.\r\n\r\n * `threads` with no argument. Tells the ppx extension to use the\r\n   `Landmark_threads` module instead of the module `Landmark`.\r\n\r\n\r\nBrowsing the JSON export using the Web Viewer\r\n---------------------------------------------\r\n\r\nYou can either compile the web viewer on your computer or\r\n[browse it online](http://LexiFi.github.io/landmarks/viewer.html).\r\nYou need to load the JSON files using the filepicker and then you can click\r\naround to browse the callgraph.\r\n\r\nInstrumenting with threads\r\n--------------------------\r\n\r\nThe `Landmark` module is not thread-safe. If you have multiple threads,\r\nyou have to make sure that at most one thread is executing instrumented\r\ncode. For that you may use the `Landmark_threads` module (included\r\nin the landmarks-threads.cm(x)a archive) that prevents non thread-safe\r\nfunctions to execute in all threads but the one which started the\r\nprofiling.\r\n\r\n\r\nInstrumenting [js_of_ocaml](http://ocsigen.org/js_of_ocaml/) programs\r\n---------------------------------------------------------------------\r\n\r\nThe package contains a bytecode archive `landmarks-noc.cma` that may\r\nbe used to build js_of_ocaml programs. This archive contains everything\r\nexcept the implementation of the `clock()` function that you\r\ntherefore need to provide in your javascript runtime.\r\n\r\n\r\nExamples\r\n--------\r\n\r\nThe example directory contains instructions to instrument some caml projects:\r\nthe ocaml compiler, the coq proof system and omake. These scripts are very\r\nfragile (as they need to patch the build systems to add the ppx-extension\r\nand to link with the right archives). You will need to adapt them if you want\r\nto benchmark other versions.\r\n\r\nInstrumenting with OCAMLPARAM\r\n-----------------------------\r\n\r\nA way to blindly instrument a project is to use ocaml's OCAMLPARAM\r\nexperimental feature, by setting the environment variable OCAMLPARAM with\r\n```\r\nI=$(ocamlfind query landmarks),cma=landmarks.cma,cmxa=landmarks.cmxa,ppx=$(ocamlfind query landmarks)/ppx_landmarks,_\"\r\n```\r\nHowever, the current implementation of OCAMLPARAM does not allow to easily\r\nbenchmark projects that build archives, shared libraries and packages. This\r\n[pull-request](https://github.com/ocaml/ocaml/pull/591) propose some improvements\r\nof OCAMLPARAM to circumvent these problems.\r\n\r\n\r\nRemarks\r\n-------\r\n\r\nThe annotation on expressions may temper with polymorphism (this is not\r\nthe case for the let-binding annotation). For instance, the following\r\npiece of code will fail to compile:\r\n```ocaml\r\n  let test = (fun x -> x)[@landmark \"test\"]\r\n  in test \"string\", test 1\r\n```\r\n\r\nAbout\r\n-----\r\n\r\nThis 'Landmarks' package is licensed by LexiFi under the terms of the\r\nMIT license.\r\n\r\nContact: marc.lasson@lexifi.com\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}