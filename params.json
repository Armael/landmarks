{
  "name": "Landmarks",
  "tagline": "",
  "body": "Landmarks: A Simple Profiling Library\r\n=====================================\r\n\r\n*Landmarks* is a simple profiling library for OCaml. It provides primitives to\r\nmeasure time spent in portion of instrumented code. The instrumentation of the\r\ncode may either done by hand, automatically or semi-automatically using a PPX\r\nextension. The result of the benchmark may be browsed either directly on the\r\nconsole, by exporting results to a simple web-application (that you can either\r\nbuild locally or access online).\r\n\r\nInstallation\r\n------------\r\n\r\n- Requirements:\r\n   * findlib (aka ocamlfind)\r\n\r\n- Optional requirements (only for building the viewer):\r\n   * gen_js_api\r\n   * js_of_ocaml\r\n\r\n- With opam (*not yet available*):\r\n```\r\nopam install landmarks\r\n```\r\n\r\n- With opam (development version):\r\n```\r\nopam pin add landmarks https://github.com/mlasson/landmarks.git\r\n```\r\n\r\n- Manually:\r\n```\r\ngit clone https://github.com/mlasson/landmarks.git\r\ncd landmarks\r\nmake\r\nmake install\r\n```\r\nand `make uninstall` to remove installed files.\r\n\r\nUsage\r\n-----\r\n\r\n* Compiling and linking:\r\n```\r\n  ocamlfind ocamlopt -c -package landmarks prog.ml\r\n  ocamlfind ocamlopt -o prog -package landmarks landmarks.cmxa prog.cmx\r\n```\r\nYou can replace \"ocamlopt\" by \"ocamlc\" to compile the program in\r\nbytecode.\r\n\r\n* With the PPX extension:\r\n```\r\n  ocamlfind ocamlopt -c -package landmarks.ppx prog.ml\r\n  ocamlfind ocamlopt -o prog -package landmarks.ppx landmarks.cmxa prog.cmx\r\n```\r\n\r\n* Launching the viewer (when available):\r\n```\r\nx-www-browser $(ocamlfind query landmarks)/landmarks_viewer.html\r\n```\r\nYou may want to replace \"x-www-browser\" with your system's way to\r\ninvoke your favorite web-browser from the command line. It has\r\nto support javascript.\r\n\r\n\r\nBenchmarking manually\r\n---------------------\r\n\r\nThere are three main primitives:\r\n```ocaml\r\n  val register: string -> landmark\r\n  val enter: landmark -> unit\r\n  val exit: landmark -> unit\r\n```\r\n\r\nThe `register` function declares new landmarks and should be used at the\r\ntoplevel. The functions `enter` and `exit` are used to delimit the portion\r\nof code attached to a landmark. At the end of the profiling, we retrieve for\r\neach landmark the aggregated time information spent executing the corresponding\r\npiece of code. During the execution, a trace of each visited landmark is also\r\nrecorded in order to build a \"callgraph\".\r\n\r\nFor example:\r\n```ocaml\r\nopen Landmark\r\n\r\nlet loop = register \"loop\"\r\nlet sleep = register \"sleep\"\r\nlet main = register \"main\"\r\n\r\nlet zzz () =\r\n  enter sleep;\r\n    Unix.sleep 1;\r\n  exit sleep\r\n\r\nlet () =\r\n  begin\r\n    start_profiling ();\r\n    enter main;\r\n      enter loop;\r\n        for _ = 1 to 9 do\r\n          zzz ()\r\n        done;\r\n      exit loop;\r\n      zzz ();\r\n    exit main;\r\n  end\r\n```\r\n(This file can be compiled with\r\n  `ocamlfind ocamlc -o prog -package landmarks landmarks.cma unix.cma prog.ml`)\r\n\r\nThe induced callgraph is:\r\n```\r\n- 100.00% : main\r\n|   - 90.00% : loop\r\n|   |   - 100.00% : sleep\r\n|   - 10.00% : sleep\r\n\r\n```\r\nwhich can be paraphrased as:\r\n- 100% of time is spent inside the main landmark,\r\n- 90% of time spent inside the main landmark is spent in the loop landmark,\r\n- 10% of time spent inside the main landmark is spent in the sleep landmark,\r\n- 100% of the time spent in loop is spent in the sleep landmark.\r\n\r\nFor more information, you may browse the [API](http://mlasson.github.io/landmarks/api/).\r\n\r\nThe `clock()` function\r\n----------------------\r\n\r\nThe library provied a binding to the [high-performance cycles counter](https://en.wikipedia.org/wiki/Time_Stamp_Counter)\r\nfor x86 32 and 64 bits architectures (note that you may use the\r\n`landmarks-noc.cm(x)a` archive to provide your own implementation). It is\r\nused to measure the time spent inside instrumented code.\r\n\r\n\r\nThe PPX extension point\r\n-----------------------\r\n\r\nTo avoid writing boilerplate code, you may use the ppx extension distributed with\r\nthis package. It allows to instrument expressions using annotation and to\r\nautomatically instrument top-level functions.\r\n\r\n### Annotations\r\n\r\nThe value `expr [@landmark \"name\"]` is expanded into\r\n```ocaml\r\n  Landmark.enter __generated_landmark_1;\r\n  let r =\r\n    try expr with e -> Landmark.exit __generated_landmark_1; raise e\r\n  in\r\n  Landmark.exit __generated_landmark_1;\r\n  r\r\n```\r\nand the declaration\r\n```ocaml\r\n  let __generated_landmark_1 = Landmark.register \"name\"\r\n```\r\nis appended at the top-level.\r\n\r\nIt should be pointed out that this transformation does not preserve\r\ntail-recursive calls (and also prevents some polymorphism generalization).\r\nTo get around these problems, it is recommended to use the other provided\r\nextension around `let ... in` and `let rec ... in`:\r\n```ocaml\r\nlet[@landmark] f = body\r\n```\r\nwhich is expanded in :\r\n```ocaml\r\nlet __generated_landmark_2 = Landmark.register \"f\"\r\nlet f = body\r\nlet f x1 ... xn =\r\n  Landmark.enter __generated_landmark_2;\r\n  let r =\r\n    try f x1 ... xn with e -> Landmark.exit __generated_landmark_2; raise e\r\n  in\r\n  Landmark.exit __generated_landmark_2;\r\n  r\r\n```\r\nwhen the arity `n` of `f` is obtained by counting the shallow occurrences\r\nof `fun ... ->` and `function ... -> ` in `body`.\r\n\r\n### Automatic instrumentation\r\n\r\nThe global annotations `[@@@landmark \"auto\"]` and `[@@@landmark \"auto-off\"]`\r\nactivates or deactivates the automatic instrumentation of top-level functions.\r\nIn automatic mode, all top-level function declarations are implicitly\r\nannotated.\r\n\r\nThe OCAML_LANDMARKS environment variable\r\n----------------------------------------\r\n\r\nWhen the landmarks module is loaded by an instrumented program, the environment\r\nvariable `OCAML_LANDMARKS` is read. If it exists the function `start_profiling`\r\nis called. This variable is parsed as a comma-separated list of items of the form\r\n`option=argument` or `option` where `option` is:\r\n\r\n * `format` with possible arguments: `textual` (default) or `json`. It controls\r\n    the output format of the profiling which is either a console friendly\r\n    representation or json encoding of the callgraph.\r\n\r\n * `output` with possible argument: `stderr` (default), `stdout`, `temporary`,\r\n   `\"<file>\"` (where `<file>` is the path a file). It tells where to output the\r\n    results of the profiling. With `temporary` it will print it in a temporary\r\n    file (the name of this file will be printed on the console).\r\n\r\n * `auto` with no argument. This option is only read by the ppx extension. It\r\n    turns on the automatic instrumentation by default (behaves as if all modules\r\n    starts with the annotation `[@@@landmark \"auto\"]`).\r\n\r\n * `debug` with no argument. Activates a verbose mode that outputs traces on\r\n   stderr each time the landmarks primitives are called.\r\n\r\n * `time` with no argument. Also collect `Sys.time` timestamps during profiling.\r\n\r\n * `off` with no argument. Disable profiling.\r\n\r\n * `allocation` with no argument. Also collect `Gc.allocated_byte` data.\r\n\r\n * `threads` with no argument. Tells the ppx extension to use the\r\n   `Landmark_threads` module instead of the module `Landmark`.\r\n\r\n\r\nBrowsing the JSON export using the Web Viewer\r\n---------------------------------------------\r\n\r\nYou can either compile the web viewer on your computer or\r\n[browse it online](http://mlasson.github.io/landmarks/viewer.html).\r\nYou need to load the JSON files using the filepicker and then you can click\r\naround to browse the callgraph.\r\n\r\nExamples\r\n--------\r\n\r\nThe example directory contains instructions to instrument some caml projects:\r\nthe ocaml compiler, the coq proof system and omake. These scripts are very\r\nfragile (as they need to patch the build systems to add the ppx-extension\r\nand to link with the right archives). You will to adapt them if you want\r\nto benchmark other versions.\r\n\r\nInstrumenting with OCAMLPARAM\r\n-----------------------------\r\n\r\nA way to blindly instrument a project is to use ocaml's OCAMLPARAM\r\nexperimental feature, by setting the environment variable OCAMLPARAM with\r\n```\r\nI=$(ocamlfind query landmarks),cma=landmarks.cma,cmxa=landmarks.cmxa,ppx=$(ocamlfind query landmarks)/ppx_landmarks,_\"\r\n```\r\nHowever, the current implementation of OCAMLPARAM does not allow to easily\r\nbenchmark projects that build archives, shared libraries and packages. This\r\n[pull-request](https://github.com/ocaml/ocaml/pull/591) propose some improvments\r\nof OCAMLPARAM to circumvent these problems.\r\n\r\n\r\nRemarks\r\n-------\r\n\r\n1. This library is not thread-safe. If you have multiple threads,\r\nyou have to make sure that at most one thread is executing instrumented\r\ncode. For that you may the `Landmark_threads` module (that is included\r\nin the landmarks-threads.cm(x)a archive).\r\n\r\n2. You should avoid to instrument small functions (and the automatic\r\nmode as no heuristic to avoid them). The instrumentation may\r\nsignificantly degrade performance.\r\n\r\n3. The annotation on expression and not the one on (local) declaration may\r\ntemper with polymorphism. For instance, the following piece of code will fail to\r\ncompile:\r\n```ocaml\r\n  let test = (fun x -> x)[@landmark \"test\"]\r\n  in test \"string\", test 1\r\n```\r\n\r\nAbout\r\n-----\r\n\r\nThis 'Landmarks' package is licensed by LexiFi under the terms of the\r\nMIT license.\r\n\r\nContact: marc.lasson@lexifi.com\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}